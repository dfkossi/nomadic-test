{"ast":null,"code":"import BigNumber from 'bignumber.js';\nimport { b58decode, validateAddress, ValidationResult, encodePubKey, encodeKey, validatePublicKey, encodeKeyHash, validateKeyHash, validateSignature, validateChain } from '@taquito/utils';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n}\n\nvar TokenValidationError =\n/** @class */\nfunction () {\n  function TokenValidationError(value, token, baseMessage) {\n    this.value = value;\n    this.token = token;\n    this.name = 'ValidationError';\n    var annot = this.token.annot();\n    var annotText = annot ? \"[\" + annot + \"] \" : '';\n    this.message = \"\" + annotText + baseMessage;\n  }\n\n  return TokenValidationError;\n}();\n\nvar Token =\n/** @class */\nfunction () {\n  function Token(val, idx, fac) {\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n    this.createToken = this.fac;\n  }\n\n  Token.prototype.annot = function () {\n    return (Array.isArray(this.val.annots) && this.val.annots.length > 0 ? this.val.annots[0] : String(this.idx)).replace(/(%|\\:)(_Liq_entry_)?/, '');\n  };\n\n  Token.prototype.hasAnnotations = function () {\n    return Array.isArray(this.val.annots) && this.val.annots.length;\n  };\n\n  Token.prototype.ExtractSignature = function () {\n    return [[this.ExtractSchema()]];\n  };\n\n  return Token;\n}();\n\nvar ComparableToken =\n/** @class */\nfunction (_super) {\n  __extends(ComparableToken, _super);\n\n  function ComparableToken() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ComparableToken.prototype.compare = function (o1, o2) {\n    return o1 < o2 ? -1 : 1;\n  };\n\n  return ComparableToken;\n}(Token);\n\nvar BigMapValidationError =\n/** @class */\nfunction (_super) {\n  __extends(BigMapValidationError, _super);\n\n  function BigMapValidationError(value, token, message) {\n    var _this = _super.call(this, value, token, message) || this;\n\n    _this.value = value;\n    _this.token = token;\n    _this.name = 'BigMapValidationError';\n    return _this;\n  }\n\n  return BigMapValidationError;\n}(TokenValidationError);\n\nvar BigMapToken =\n/** @class */\nfunction (_super) {\n  __extends(BigMapToken, _super);\n\n  function BigMapToken(val, idx, fac) {\n    var _this = _super.call(this, val, idx, fac) || this;\n\n    _this.val = val;\n    _this.idx = idx;\n    _this.fac = fac;\n    return _this;\n  }\n\n  Object.defineProperty(BigMapToken.prototype, \"ValueSchema\", {\n    get: function () {\n      return this.createToken(this.val.args[1], 0);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BigMapToken.prototype, \"KeySchema\", {\n    get: function () {\n      return this.createToken(this.val.args[0], 0);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  BigMapToken.prototype.ExtractSchema = function () {\n    var _a;\n\n    return _a = {}, _a[this.KeySchema.ExtractSchema()] = this.ValueSchema.ExtractSchema(), _a;\n  };\n\n  BigMapToken.prototype.isValid = function (value) {\n    if (typeof value === 'object') {\n      return null;\n    }\n\n    return new BigMapValidationError(value, this, 'Value must be an object');\n  };\n\n  BigMapToken.prototype.Encode = function (args) {\n    var _this = this;\n\n    var val = args.pop();\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return Object.keys(val).sort(this.KeySchema.compare).map(function (key) {\n      return {\n        prim: 'Elt',\n        args: [_this.KeySchema.Encode([key]), _this.ValueSchema.EncodeObject(val[key])]\n      };\n    });\n  };\n\n  BigMapToken.prototype.EncodeObject = function (args) {\n    var _this = this;\n\n    var val = args;\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return Object.keys(val).sort(this.KeySchema.compare).map(function (key) {\n      return {\n        prim: 'Elt',\n        args: [_this.KeySchema.EncodeObject(key), _this.ValueSchema.EncodeObject(val[key])]\n      };\n    });\n  };\n\n  BigMapToken.prototype.Execute = function (val, semantic) {\n    var _this = this;\n\n    if (semantic && semantic[BigMapToken.prim]) {\n      return semantic[BigMapToken.prim](val, this.val);\n    }\n\n    if (Array.isArray(val)) {\n      // Athens is returning an empty array for big map in storage\n      // Internal: In taquito v5 it is still used to decode big map diff (as if they were a regular map)\n      return val.reduce(function (prev, current) {\n        var _a;\n\n        return __assign(__assign({}, prev), (_a = {}, _a[_this.KeySchema.ToKey(current.args[0])] = _this.ValueSchema.Execute(current.args[1]), _a));\n      }, {});\n    } else if ('int' in val) {\n      // Babylon is returning an int with the big map id in contract storage\n      return val.int;\n    } else {\n      // Unknown case\n      throw new Error(\"Big map is expecting either an array (Athens) or an object with an int property (Babylon). Got \" + JSON.stringify(val));\n    }\n  };\n\n  BigMapToken.prim = 'big_map';\n  return BigMapToken;\n}(Token);\n\nvar OrToken =\n/** @class */\nfunction (_super) {\n  __extends(OrToken, _super);\n\n  function OrToken(val, idx, fac) {\n    var _this = _super.call(this, val, idx, fac) || this;\n\n    _this.val = val;\n    _this.idx = idx;\n    _this.fac = fac;\n    return _this;\n  }\n\n  OrToken.prototype.Encode = function (args) {\n    var label = args[args.length - 1];\n    var leftToken = this.createToken(this.val.args[0], this.idx);\n    var keyCount = 1;\n\n    if (leftToken instanceof OrToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n\n    var rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n\n    if (String(leftToken.annot()) === String(label) && !(leftToken instanceof OrToken)) {\n      args.pop();\n      return {\n        prim: 'Left',\n        args: [leftToken.Encode(args)]\n      };\n    } else if (String(rightToken.annot()) === String(label) && !(rightToken instanceof OrToken)) {\n      args.pop();\n      return {\n        prim: 'Right',\n        args: [rightToken.Encode(args)]\n      };\n    } else {\n      if (leftToken instanceof OrToken) {\n        var val = leftToken.Encode(args);\n\n        if (val) {\n          return {\n            prim: 'Left',\n            args: [val]\n          };\n        }\n      }\n\n      if (rightToken instanceof OrToken) {\n        var val = rightToken.Encode(args);\n\n        if (val) {\n          return {\n            prim: 'Right',\n            args: [val]\n          };\n        }\n      }\n\n      return null;\n    }\n  };\n\n  OrToken.prototype.ExtractSignature = function () {\n    var leftToken = this.createToken(this.val.args[0], this.idx);\n    var keyCount = 1;\n\n    if (leftToken instanceof OrToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n\n    var rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n    var newSig = [];\n\n    if (leftToken instanceof OrToken) {\n      newSig.push.apply(newSig, leftToken.ExtractSignature());\n    } else {\n      for (var _i = 0, _a = leftToken.ExtractSignature(); _i < _a.length; _i++) {\n        var sig = _a[_i];\n        newSig.push(__spreadArrays([leftToken.annot()], sig));\n      }\n    }\n\n    if (rightToken instanceof OrToken) {\n      newSig.push.apply(newSig, rightToken.ExtractSignature());\n    } else {\n      for (var _b = 0, _c = rightToken.ExtractSignature(); _b < _c.length; _b++) {\n        var sig = _c[_b];\n        newSig.push(__spreadArrays([rightToken.annot()], sig));\n      }\n    }\n\n    return newSig;\n  };\n\n  OrToken.prototype.EncodeObject = function (args) {\n    var label = Object.keys(args)[0];\n    var leftToken = this.createToken(this.val.args[0], this.idx);\n    var keyCount = 1;\n\n    if (leftToken instanceof OrToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n\n    var rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n\n    if (String(leftToken.annot()) === String(label) && !(leftToken instanceof OrToken)) {\n      return {\n        prim: 'Left',\n        args: [leftToken.EncodeObject(args[label])]\n      };\n    } else if (String(rightToken.annot()) === String(label) && !(rightToken instanceof OrToken)) {\n      return {\n        prim: 'Right',\n        args: [rightToken.EncodeObject(args[label])]\n      };\n    } else {\n      if (leftToken instanceof OrToken) {\n        var val = leftToken.EncodeObject(args);\n\n        if (val) {\n          return {\n            prim: 'Left',\n            args: [val]\n          };\n        }\n      }\n\n      if (rightToken instanceof OrToken) {\n        var val = rightToken.EncodeObject(args);\n\n        if (val) {\n          return {\n            prim: 'Right',\n            args: [val]\n          };\n        }\n      }\n\n      return null;\n    }\n  };\n\n  OrToken.prototype.Execute = function (val, semantics) {\n    var _a;\n\n    var leftToken = this.createToken(this.val.args[0], this.idx);\n    var keyCount = 1;\n\n    if (leftToken instanceof OrToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n\n    var rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n\n    if (val.prim === 'Right') {\n      return rightToken.Execute(val.args[0], semantics);\n    } else if (val.prim === 'Left') {\n      return _a = {}, _a[leftToken.annot()] = leftToken.Execute(val.args[0], semantics), _a;\n    } else {\n      throw new Error(\"Was expecting Left or Right prim but got: \" + val.prim);\n    }\n  };\n\n  OrToken.prototype.traversal = function (getLeftValue, getRightValue, concat) {\n    var _a, _b;\n\n    var leftToken = this.createToken(this.val.args[0], this.idx);\n    var keyCount = 1;\n    var leftValue;\n\n    if (leftToken instanceof OrToken && !leftToken.hasAnnotations()) {\n      leftValue = getLeftValue(leftToken);\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    } else {\n      leftValue = (_a = {}, _a[leftToken.annot()] = getLeftValue(leftToken), _a);\n    }\n\n    var rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n    var rightValue;\n\n    if (rightToken instanceof OrToken && !rightToken.hasAnnotations()) {\n      rightValue = getRightValue(rightToken);\n    } else {\n      rightValue = (_b = {}, _b[rightToken.annot()] = getRightValue(rightToken), _b);\n    }\n\n    var res = concat(leftValue, rightValue);\n    return res;\n  };\n\n  OrToken.prototype.ExtractSchema = function () {\n    return this.traversal(function (leftToken) {\n      return leftToken.ExtractSchema();\n    }, function (rightToken) {\n      return rightToken.ExtractSchema();\n    }, function (leftValue, rightValue) {\n      return __assign(__assign({}, leftValue), rightValue);\n    });\n  };\n\n  OrToken.prim = 'or';\n  return OrToken;\n}(Token);\n\nvar PairToken =\n/** @class */\nfunction (_super) {\n  __extends(PairToken, _super);\n\n  function PairToken(val, idx, fac) {\n    var _this = _super.call(this, val, idx, fac) || this;\n\n    _this.val = val;\n    _this.idx = idx;\n    _this.fac = fac;\n    return _this;\n  }\n\n  PairToken.prototype.Encode = function (args) {\n    var leftToken = this.createToken(this.val.args[0], this.idx);\n    var keyCount = 1;\n\n    if (leftToken instanceof PairToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n\n    var rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n    return {\n      prim: 'Pair',\n      args: [leftToken.Encode(args), rightToken.Encode(args)]\n    };\n  };\n\n  PairToken.prototype.ExtractSignature = function () {\n    var leftToken = this.createToken(this.val.args[0], this.idx);\n    var keyCount = 1;\n\n    if (leftToken instanceof OrToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n\n    var rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n    var newSig = [];\n\n    for (var _i = 0, _a = leftToken.ExtractSignature(); _i < _a.length; _i++) {\n      var leftSig = _a[_i];\n\n      for (var _b = 0, _c = rightToken.ExtractSignature(); _b < _c.length; _b++) {\n        var rightSig = _c[_b];\n        newSig.push(__spreadArrays(leftSig, rightSig));\n      }\n    }\n\n    return newSig;\n  };\n\n  PairToken.prototype.EncodeObject = function (args) {\n    var leftToken = this.createToken(this.val.args[0], this.idx);\n    var keyCount = 1;\n\n    if (leftToken instanceof PairToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n\n    var rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n    var leftValue;\n\n    if (leftToken instanceof PairToken && !leftToken.hasAnnotations()) {\n      leftValue = args;\n    } else {\n      leftValue = args[leftToken.annot()];\n    }\n\n    var rightValue;\n\n    if (rightToken instanceof PairToken && !rightToken.hasAnnotations()) {\n      rightValue = args;\n    } else {\n      rightValue = args[rightToken.annot()];\n    }\n\n    return {\n      prim: 'Pair',\n      args: [leftToken.EncodeObject(leftValue), rightToken.EncodeObject(rightValue)]\n    };\n  };\n\n  PairToken.prototype.traversal = function (getLeftValue, getRightValue) {\n    var _a, _b;\n\n    var leftToken = this.createToken(this.val.args[0], this.idx);\n    var keyCount = 1;\n    var leftValue;\n\n    if (leftToken instanceof PairToken && !leftToken.hasAnnotations()) {\n      leftValue = getLeftValue(leftToken);\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    } else {\n      leftValue = (_a = {}, _a[leftToken.annot()] = getLeftValue(leftToken), _a);\n    }\n\n    var rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n    var rightValue;\n\n    if (rightToken instanceof PairToken && !rightToken.hasAnnotations()) {\n      rightValue = getRightValue(rightToken);\n    } else {\n      rightValue = (_b = {}, _b[rightToken.annot()] = getRightValue(rightToken), _b);\n    }\n\n    var res = __assign(__assign({}, leftValue), rightValue);\n\n    return res;\n  };\n\n  PairToken.prototype.Execute = function (val, semantics) {\n    return this.traversal(function (leftToken) {\n      return leftToken.Execute(val.args[0], semantics);\n    }, function (rightToken) {\n      return rightToken.Execute(val.args[1], semantics);\n    });\n  };\n\n  PairToken.prototype.ExtractSchema = function () {\n    return this.traversal(function (leftToken) {\n      return leftToken.ExtractSchema();\n    }, function (rightToken) {\n      return rightToken.ExtractSchema();\n    });\n  };\n\n  PairToken.prim = 'pair';\n  return PairToken;\n}(Token);\n\nvar NatValidationError =\n/** @class */\nfunction (_super) {\n  __extends(NatValidationError, _super);\n\n  function NatValidationError(value, token, message) {\n    var _this = _super.call(this, value, token, message) || this;\n\n    _this.value = value;\n    _this.token = token;\n    _this.name = 'NatValidationError';\n    return _this;\n  }\n\n  return NatValidationError;\n}(TokenValidationError);\n\nvar NatToken =\n/** @class */\nfunction (_super) {\n  __extends(NatToken, _super);\n\n  function NatToken(val, idx, fac) {\n    var _this = _super.call(this, val, idx, fac) || this;\n\n    _this.val = val;\n    _this.idx = idx;\n    _this.fac = fac;\n    return _this;\n  }\n\n  NatToken.prototype.Execute = function (val) {\n    return new BigNumber(val[Object.keys(val)[0]]);\n  };\n\n  NatToken.prototype.Encode = function (args) {\n    var val = args.pop();\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      int: String(val).toString()\n    };\n  };\n\n  NatToken.prototype.isValid = function (val) {\n    var bigNumber = new BigNumber(val);\n\n    if (bigNumber.isNaN()) {\n      return new NatValidationError(val, this, \"Value is not a number: \" + val);\n    } else if (bigNumber.isNegative()) {\n      return new NatValidationError(val, this, \"Value cannot be negative: \" + val);\n    } else {\n      return null;\n    }\n  };\n\n  NatToken.prototype.EncodeObject = function (val) {\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      int: String(val).toString()\n    };\n  };\n\n  NatToken.prototype.ExtractSchema = function () {\n    return NatToken.prim;\n  };\n\n  NatToken.prototype.ToBigMapKey = function (val) {\n    return {\n      key: {\n        int: val\n      },\n      type: {\n        prim: NatToken.prim\n      }\n    };\n  };\n\n  NatToken.prototype.ToKey = function (_a) {\n    var int = _a.int;\n    return int;\n  };\n\n  NatToken.prim = 'nat';\n  return NatToken;\n}(ComparableToken);\n\nvar StringToken =\n/** @class */\nfunction (_super) {\n  __extends(StringToken, _super);\n\n  function StringToken(val, idx, fac) {\n    var _this = _super.call(this, val, idx, fac) || this;\n\n    _this.val = val;\n    _this.idx = idx;\n    _this.fac = fac;\n    return _this;\n  }\n\n  StringToken.prototype.Execute = function (val) {\n    return val[Object.keys(val)[0]];\n  };\n\n  StringToken.prototype.ExtractSchema = function () {\n    return StringToken.prim;\n  };\n\n  StringToken.prototype.Encode = function (args) {\n    var val = args.pop();\n    return {\n      string: val\n    };\n  };\n\n  StringToken.prototype.EncodeObject = function (val) {\n    return {\n      string: val\n    };\n  }; // tslint:disable-next-line: variable-name\n\n\n  StringToken.prototype.ToKey = function (_a) {\n    var string = _a.string;\n    return string;\n  };\n\n  StringToken.prototype.ToBigMapKey = function (val) {\n    return {\n      key: {\n        string: val\n      },\n      type: {\n        prim: StringToken.prim\n      }\n    };\n  };\n\n  StringToken.prim = 'string';\n  return StringToken;\n}(ComparableToken);\n\nvar AddressValidationError =\n/** @class */\nfunction (_super) {\n  __extends(AddressValidationError, _super);\n\n  function AddressValidationError(value, token, message) {\n    var _this = _super.call(this, value, token, message) || this;\n\n    _this.value = value;\n    _this.token = token;\n    _this.name = 'AddressValidationError';\n    return _this;\n  }\n\n  return AddressValidationError;\n}(TokenValidationError);\n\nvar AddressToken =\n/** @class */\nfunction (_super) {\n  __extends(AddressToken, _super);\n\n  function AddressToken(val, idx, fac) {\n    var _this = _super.call(this, val, idx, fac) || this;\n\n    _this.val = val;\n    _this.idx = idx;\n    _this.fac = fac;\n    return _this;\n  }\n\n  AddressToken.prototype.ToBigMapKey = function (val) {\n    var decoded = b58decode(val);\n    return {\n      key: {\n        bytes: decoded\n      },\n      type: {\n        prim: 'bytes'\n      }\n    };\n  };\n\n  AddressToken.prototype.isValid = function (value) {\n    if (validateAddress(value) !== ValidationResult.VALID) {\n      return new AddressValidationError(value, this, \"Address is not valid: \" + value);\n    }\n\n    return null;\n  };\n\n  AddressToken.prototype.Encode = function (args) {\n    var val = args.pop();\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      string: val\n    };\n  };\n\n  AddressToken.prototype.EncodeObject = function (val) {\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      string: val\n    };\n  }; // tslint:disable-next-line: variable-name\n\n\n  AddressToken.prototype.Execute = function (val) {\n    if (val.string) {\n      return val.string;\n    }\n\n    return encodePubKey(val.bytes);\n  };\n\n  AddressToken.prototype.ExtractSchema = function () {\n    return AddressToken.prim;\n  }; // tslint:disable-next-line: variable-name\n\n\n  AddressToken.prototype.ToKey = function (_a) {\n    var bytes = _a.bytes,\n        string = _a.string;\n\n    if (string) {\n      return string;\n    }\n\n    return encodePubKey(bytes);\n  };\n\n  AddressToken.prototype.compare = function (address1, address2) {\n    var isImplicit = function (address) {\n      return address.startsWith('tz');\n    };\n\n    if (isImplicit(address1) && isImplicit(address2)) {\n      return _super.prototype.compare.call(this, address1, address2);\n    } else if (isImplicit(address1)) {\n      return -1;\n    } else if (isImplicit(address2)) {\n      return 1;\n    } else {\n      return _super.prototype.compare.call(this, address1, address2);\n    }\n  };\n\n  AddressToken.prim = 'address';\n  return AddressToken;\n}(ComparableToken);\n\nvar MapValidationError =\n/** @class */\nfunction (_super) {\n  __extends(MapValidationError, _super);\n\n  function MapValidationError(value, token, message) {\n    var _this = _super.call(this, value, token, message) || this;\n\n    _this.value = value;\n    _this.token = token;\n    _this.name = 'MapValidationError';\n    return _this;\n  }\n\n  return MapValidationError;\n}(TokenValidationError);\n\nvar MapToken =\n/** @class */\nfunction (_super) {\n  __extends(MapToken, _super);\n\n  function MapToken(val, idx, fac) {\n    var _this = _super.call(this, val, idx, fac) || this;\n\n    _this.val = val;\n    _this.idx = idx;\n    _this.fac = fac;\n    return _this;\n  }\n\n  Object.defineProperty(MapToken.prototype, \"ValueSchema\", {\n    get: function () {\n      return this.createToken(this.val.args[1], 0);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapToken.prototype, \"KeySchema\", {\n    get: function () {\n      return this.createToken(this.val.args[0], 0);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MapToken.prototype.isValid = function (value) {\n    if (typeof value === 'object') {\n      return null;\n    }\n\n    return new MapValidationError(value, this, 'Value must be an object');\n  };\n\n  MapToken.prototype.Execute = function (val, semantics) {\n    var _this = this;\n\n    return val.reduce(function (prev, current) {\n      var _a;\n\n      return __assign(__assign({}, prev), (_a = {}, _a[_this.KeySchema.ToKey(current.args[0])] = _this.ValueSchema.Execute(current.args[1], semantics), _a));\n    }, {});\n  };\n\n  MapToken.prototype.Encode = function (args) {\n    var _this = this;\n\n    var val = args.pop();\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return Object.keys(val).sort(this.KeySchema.compare).map(function (key) {\n      return {\n        prim: 'Elt',\n        args: [_this.KeySchema.Encode([key]), _this.ValueSchema.EncodeObject(val[key])]\n      };\n    });\n  };\n\n  MapToken.prototype.EncodeObject = function (args) {\n    var _this = this;\n\n    var val = args;\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return Object.keys(val).sort(this.KeySchema.compare).map(function (key) {\n      return {\n        prim: 'Elt',\n        args: [_this.KeySchema.EncodeObject(key), _this.ValueSchema.EncodeObject(val[key])]\n      };\n    });\n  };\n\n  MapToken.prototype.ExtractSchema = function () {\n    var _a;\n\n    return _a = {}, _a[this.KeySchema.ExtractSchema()] = this.ValueSchema.ExtractSchema(), _a;\n  };\n\n  MapToken.prim = 'map';\n  return MapToken;\n}(Token);\n\nvar BoolToken =\n/** @class */\nfunction (_super) {\n  __extends(BoolToken, _super);\n\n  function BoolToken(val, idx, fac) {\n    var _this = _super.call(this, val, idx, fac) || this;\n\n    _this.val = val;\n    _this.idx = idx;\n    _this.fac = fac;\n    return _this;\n  }\n\n  BoolToken.prototype.Execute = function (val) {\n    return String(val.prim).toLowerCase() === 'true' ? true : false;\n  };\n\n  BoolToken.prototype.Encode = function (args) {\n    var val = args.pop();\n    return {\n      prim: val ? 'True' : 'False'\n    };\n  };\n\n  BoolToken.prototype.EncodeObject = function (val) {\n    return {\n      prim: val ? 'True' : 'False'\n    };\n  };\n\n  BoolToken.prototype.ExtractSchema = function () {\n    return BoolToken.prim;\n  };\n\n  BoolToken.prim = 'bool';\n  return BoolToken;\n}(Token);\n\nvar ContractValidationError =\n/** @class */\nfunction (_super) {\n  __extends(ContractValidationError, _super);\n\n  function ContractValidationError(value, token, message) {\n    var _this = _super.call(this, value, token, message) || this;\n\n    _this.value = value;\n    _this.token = token;\n    _this.name = 'ContractValidationError';\n    return _this;\n  }\n\n  return ContractValidationError;\n}(TokenValidationError);\n\nvar ContractToken =\n/** @class */\nfunction (_super) {\n  __extends(ContractToken, _super);\n\n  function ContractToken(val, idx, fac) {\n    var _this = _super.call(this, val, idx, fac) || this;\n\n    _this.val = val;\n    _this.idx = idx;\n    _this.fac = fac;\n    return _this;\n  }\n\n  ContractToken.prototype.isValid = function (value) {\n    // tz1,tz2 and tz3 seems to be valid contract values (for Unit contract)\n    if (validateAddress(value) !== ValidationResult.VALID) {\n      return new ContractValidationError(value, this, 'Contract address is not valid');\n    }\n\n    return null;\n  };\n\n  ContractToken.prototype.Execute = function (val) {\n    if (val.string) {\n      return val.string;\n    }\n\n    return encodePubKey(val.bytes);\n  };\n\n  ContractToken.prototype.Encode = function (args) {\n    var val = args.pop();\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      string: val\n    };\n  };\n\n  ContractToken.prototype.EncodeObject = function (val) {\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      string: val\n    };\n  };\n\n  ContractToken.prototype.ExtractSchema = function () {\n    return ContractToken.prim;\n  };\n\n  ContractToken.prim = 'contract';\n  return ContractToken;\n}(Token);\n\nvar ListValidationError =\n/** @class */\nfunction (_super) {\n  __extends(ListValidationError, _super);\n\n  function ListValidationError(value, token, message) {\n    var _this = _super.call(this, value, token, message) || this;\n\n    _this.value = value;\n    _this.token = token;\n    _this.name = 'ListValidationError';\n    return _this;\n  }\n\n  return ListValidationError;\n}(TokenValidationError);\n\nvar ListToken =\n/** @class */\nfunction (_super) {\n  __extends(ListToken, _super);\n\n  function ListToken(val, idx, fac) {\n    var _this = _super.call(this, val, idx, fac) || this;\n\n    _this.val = val;\n    _this.idx = idx;\n    _this.fac = fac;\n    return _this;\n  }\n\n  ListToken.prototype.isValid = function (value) {\n    if (Array.isArray(value)) {\n      return null;\n    }\n\n    return new ListValidationError(value, this, 'Value must be an array');\n  };\n\n  ListToken.prototype.Encode = function (args) {\n    var val = args.pop();\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    var schema = this.createToken(this.val.args[0], 0);\n    return val.reduce(function (prev, current) {\n      return __spreadArrays(prev, [schema.EncodeObject(current)]);\n    }, []);\n  };\n\n  ListToken.prototype.Execute = function (val, semantics) {\n    var schema = this.createToken(this.val.args[0], 0);\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return val.reduce(function (prev, current) {\n      return __spreadArrays(prev, [schema.Execute(current, semantics)]);\n    }, []);\n  };\n\n  ListToken.prototype.EncodeObject = function (args) {\n    var schema = this.createToken(this.val.args[0], 0);\n    var err = this.isValid(args);\n\n    if (err) {\n      throw err;\n    }\n\n    return args.reduce(function (prev, current) {\n      return __spreadArrays(prev, [schema.EncodeObject(current)]);\n    }, []);\n  };\n\n  ListToken.prototype.ExtractSchema = function () {\n    return ListToken.prim;\n  };\n\n  ListToken.prim = 'list';\n  return ListToken;\n}(Token);\n\nvar MutezValidationError =\n/** @class */\nfunction (_super) {\n  __extends(MutezValidationError, _super);\n\n  function MutezValidationError(value, token, message) {\n    var _this = _super.call(this, value, token, message) || this;\n\n    _this.value = value;\n    _this.token = token;\n    _this.name = 'MutezValidationError';\n    return _this;\n  }\n\n  return MutezValidationError;\n}(TokenValidationError);\n\nvar MutezToken =\n/** @class */\nfunction (_super) {\n  __extends(MutezToken, _super);\n\n  function MutezToken(val, idx, fac) {\n    var _this = _super.call(this, val, idx, fac) || this;\n\n    _this.val = val;\n    _this.idx = idx;\n    _this.fac = fac;\n    return _this;\n  }\n\n  MutezToken.prototype.Execute = function (val) {\n    return new BigNumber(val[Object.keys(val)[0]]);\n  };\n\n  MutezToken.prototype.ExtractSchema = function () {\n    return MutezToken.prim;\n  };\n\n  MutezToken.prototype.isValid = function (val) {\n    var bigNumber = new BigNumber(val);\n\n    if (bigNumber.isNaN()) {\n      return new MutezValidationError(val, this, \"Value is not a number: \" + val);\n    } else {\n      return null;\n    }\n  };\n\n  MutezToken.prototype.Encode = function (args) {\n    var val = args.pop();\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      int: String(val).toString()\n    };\n  };\n\n  MutezToken.prototype.EncodeObject = function (val) {\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      int: String(val).toString()\n    };\n  };\n\n  MutezToken.prototype.ToBigMapKey = function (val) {\n    return {\n      key: {\n        int: val\n      },\n      type: {\n        prim: MutezToken.prim\n      }\n    };\n  };\n\n  MutezToken.prototype.ToKey = function (_a) {\n    var int = _a.int;\n    return int;\n  };\n\n  MutezToken.prim = 'mutez';\n  return MutezToken;\n}(ComparableToken);\n\nvar BytesValidationError =\n/** @class */\nfunction (_super) {\n  __extends(BytesValidationError, _super);\n\n  function BytesValidationError(value, token, message) {\n    var _this = _super.call(this, value, token, message) || this;\n\n    _this.value = value;\n    _this.token = token;\n    _this.name = 'BytesValidationError';\n    return _this;\n  }\n\n  return BytesValidationError;\n}(TokenValidationError);\n\nvar BytesToken =\n/** @class */\nfunction (_super) {\n  __extends(BytesToken, _super);\n\n  function BytesToken(val, idx, fac) {\n    var _this = _super.call(this, val, idx, fac) || this;\n\n    _this.val = val;\n    _this.idx = idx;\n    _this.fac = fac;\n    return _this;\n  }\n\n  BytesToken.prototype.ToBigMapKey = function (val) {\n    return {\n      key: {\n        bytes: val\n      },\n      type: {\n        prim: BytesToken.prim\n      }\n    };\n  };\n\n  BytesToken.prototype.isValid = function (val) {\n    if (typeof val === 'string' && /^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {\n      return null;\n    } else {\n      return new BytesValidationError(val, this, \"Invalid bytes: \" + val);\n    }\n  };\n\n  BytesToken.prototype.Encode = function (args) {\n    var val = args.pop();\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      bytes: String(val).toString()\n    };\n  };\n\n  BytesToken.prototype.EncodeObject = function (val) {\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      bytes: String(val).toString()\n    };\n  };\n\n  BytesToken.prototype.Execute = function (val) {\n    return val.bytes;\n  };\n\n  BytesToken.prototype.ExtractSchema = function () {\n    return BytesToken.prim;\n  }; // tslint:disable-next-line: variable-name\n\n\n  BytesToken.prototype.ToKey = function (_a) {\n    var bytes = _a.bytes,\n        string = _a.string;\n\n    if (string) {\n      return string;\n    }\n\n    return bytes;\n  };\n\n  BytesToken.prim = 'bytes';\n  return BytesToken;\n}(ComparableToken);\n\nvar OptionToken =\n/** @class */\nfunction (_super) {\n  __extends(OptionToken, _super);\n\n  function OptionToken(val, idx, fac) {\n    var _this = _super.call(this, val, idx, fac) || this;\n\n    _this.val = val;\n    _this.idx = idx;\n    _this.fac = fac;\n    return _this;\n  }\n\n  OptionToken.prototype.subToken = function () {\n    return this.createToken(this.val.args[0], this.idx);\n  };\n\n  OptionToken.prototype.annot = function () {\n    return Array.isArray(this.val.annots) ? _super.prototype.annot.call(this) : this.createToken(this.val.args[0], this.idx).annot();\n  };\n\n  OptionToken.prototype.Encode = function (args) {\n    var value = args;\n\n    if (value === undefined || value === null || Array.isArray(value) && (value[0] === undefined || value[0] === null)) {\n      return {\n        prim: 'None'\n      };\n    }\n\n    var schema = this.createToken(this.val.args[0], 0);\n    return {\n      prim: 'Some',\n      args: [schema.Encode(args)]\n    };\n  };\n\n  OptionToken.prototype.EncodeObject = function (args) {\n    var schema = this.createToken(this.val.args[0], 0);\n    var value = args;\n\n    if (value === undefined || value === null) {\n      return {\n        prim: 'None'\n      };\n    }\n\n    return {\n      prim: 'Some',\n      args: [schema.EncodeObject(value)]\n    };\n  };\n\n  OptionToken.prototype.Execute = function (val, semantics) {\n    if (val.prim === 'None') {\n      return null;\n    }\n\n    var schema = this.createToken(this.val.args[0], 0);\n    return schema.Execute(val.args[0], semantics);\n  };\n\n  OptionToken.prototype.ExtractSchema = function () {\n    var schema = this.createToken(this.val.args[0], 0);\n    return schema.ExtractSchema();\n  };\n\n  OptionToken.prototype.ExtractSignature = function () {\n    var schema = this.createToken(this.val.args[0], 0);\n    return __spreadArrays(schema.ExtractSignature(), [[]]);\n  };\n\n  OptionToken.prim = 'option';\n  return OptionToken;\n}(Token);\n\nvar TimestampToken =\n/** @class */\nfunction (_super) {\n  __extends(TimestampToken, _super);\n\n  function TimestampToken(val, idx, fac) {\n    var _this = _super.call(this, val, idx, fac) || this;\n\n    _this.val = val;\n    _this.idx = idx;\n    _this.fac = fac;\n    return _this;\n  }\n\n  TimestampToken.prototype.Execute = function (val) {\n    if (val.string) {\n      return new Date(val.string).toISOString();\n    } else if (val.int) {\n      return new Date(Number(val.int) * 1000).toISOString();\n    }\n  };\n\n  TimestampToken.prototype.Encode = function (args) {\n    var val = args.pop();\n    return {\n      string: val\n    };\n  };\n\n  TimestampToken.prototype.EncodeObject = function (val) {\n    return {\n      string: val\n    };\n  };\n\n  TimestampToken.prototype.ExtractSchema = function () {\n    return TimestampToken.prim;\n  }; // tslint:disable-next-line: variable-name\n\n\n  TimestampToken.prototype.ToKey = function (_a) {\n    var string = _a.string;\n    return string;\n  };\n\n  TimestampToken.prototype.ToBigMapKey = function (val) {\n    return {\n      key: {\n        string: val\n      },\n      type: {\n        prim: TimestampToken.prim\n      }\n    };\n  };\n\n  TimestampToken.prim = 'timestamp';\n  return TimestampToken;\n}(ComparableToken);\n\nvar IntValidationError =\n/** @class */\nfunction (_super) {\n  __extends(IntValidationError, _super);\n\n  function IntValidationError(value, token, message) {\n    var _this = _super.call(this, value, token, message) || this;\n\n    _this.value = value;\n    _this.token = token;\n    _this.name = 'IntValidationError';\n    return _this;\n  }\n\n  return IntValidationError;\n}(TokenValidationError);\n\nvar IntToken =\n/** @class */\nfunction (_super) {\n  __extends(IntToken, _super);\n\n  function IntToken(val, idx, fac) {\n    var _this = _super.call(this, val, idx, fac) || this;\n\n    _this.val = val;\n    _this.idx = idx;\n    _this.fac = fac;\n    return _this;\n  }\n\n  IntToken.prototype.Execute = function (val) {\n    return new BigNumber(val[Object.keys(val)[0]]);\n  };\n\n  IntToken.prototype.ExtractSchema = function () {\n    return IntToken.prim;\n  };\n\n  IntToken.prototype.isValid = function (val) {\n    var bigNumber = new BigNumber(val);\n\n    if (bigNumber.isNaN()) {\n      return new IntValidationError(val, this, \"Value is not a number: \" + val);\n    } else {\n      return null;\n    }\n  };\n\n  IntToken.prototype.Encode = function (args) {\n    var val = args.pop();\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      int: String(val).toString()\n    };\n  };\n\n  IntToken.prototype.EncodeObject = function (val) {\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      int: String(val).toString()\n    };\n  };\n\n  IntToken.prototype.ToBigMapKey = function (val) {\n    return {\n      key: {\n        int: val\n      },\n      type: {\n        prim: IntToken.prim\n      }\n    };\n  };\n\n  IntToken.prototype.ToKey = function (_a) {\n    var int = _a.int;\n    return int;\n  };\n\n  IntToken.prim = 'int';\n  return IntToken;\n}(ComparableToken);\n\nvar UnitToken =\n/** @class */\nfunction (_super) {\n  __extends(UnitToken, _super);\n\n  function UnitToken(val, idx, fac) {\n    var _this = _super.call(this, val, idx, fac) || this;\n\n    _this.val = val;\n    _this.idx = idx;\n    _this.fac = fac;\n    return _this;\n  }\n\n  UnitToken.prototype.Encode = function (args) {\n    args.pop();\n    return {\n      prim: 'Unit'\n    };\n  };\n\n  UnitToken.prototype.EncodeObject = function (_val) {\n    return {\n      prim: 'Unit'\n    };\n  };\n\n  UnitToken.prototype.Execute = function () {\n    return null;\n  };\n\n  UnitToken.prototype.ExtractSchema = function () {\n    return UnitToken.prim;\n  };\n\n  UnitToken.prim = 'unit';\n  return UnitToken;\n}(Token);\n\nvar KeyValidationError =\n/** @class */\nfunction (_super) {\n  __extends(KeyValidationError, _super);\n\n  function KeyValidationError(value, token, message) {\n    var _this = _super.call(this, value, token, message) || this;\n\n    _this.value = value;\n    _this.token = token;\n    _this.name = 'KeyValidationError';\n    return _this;\n  }\n\n  return KeyValidationError;\n}(TokenValidationError);\n\nvar KeyToken =\n/** @class */\nfunction (_super) {\n  __extends(KeyToken, _super);\n\n  function KeyToken(val, idx, fac) {\n    var _this = _super.call(this, val, idx, fac) || this;\n\n    _this.val = val;\n    _this.idx = idx;\n    _this.fac = fac;\n    return _this;\n  }\n\n  KeyToken.prototype.Execute = function (val) {\n    if (val.string) {\n      return val.string;\n    }\n\n    return encodeKey(val.bytes);\n  };\n\n  KeyToken.prototype.isValid = function (value) {\n    if (validatePublicKey(value) !== ValidationResult.VALID) {\n      return new KeyValidationError(value, this, 'Key is not valid');\n    }\n\n    return null;\n  };\n\n  KeyToken.prototype.Encode = function (args) {\n    var val = args.pop();\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      string: val\n    };\n  };\n\n  KeyToken.prototype.EncodeObject = function (val) {\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      string: val\n    };\n  };\n\n  KeyToken.prototype.ExtractSchema = function () {\n    return KeyToken.prim;\n  };\n\n  KeyToken.prim = 'key';\n  return KeyToken;\n}(Token);\n\nvar KeyHashValidationError =\n/** @class */\nfunction (_super) {\n  __extends(KeyHashValidationError, _super);\n\n  function KeyHashValidationError(value, token, message) {\n    var _this = _super.call(this, value, token, message) || this;\n\n    _this.value = value;\n    _this.token = token;\n    _this.name = 'KeyHashValidationError';\n    return _this;\n  }\n\n  return KeyHashValidationError;\n}(TokenValidationError);\n\nvar KeyHashToken =\n/** @class */\nfunction (_super) {\n  __extends(KeyHashToken, _super);\n\n  function KeyHashToken(val, idx, fac) {\n    var _this = _super.call(this, val, idx, fac) || this;\n\n    _this.val = val;\n    _this.idx = idx;\n    _this.fac = fac;\n    return _this;\n  }\n\n  KeyHashToken.prototype.Execute = function (val) {\n    if (val.string) {\n      return val.string;\n    }\n\n    return encodeKeyHash(val.bytes);\n  };\n\n  KeyHashToken.prototype.isValid = function (value) {\n    if (validateKeyHash(value) !== ValidationResult.VALID) {\n      return new KeyHashValidationError(value, this, \"KeyHash is not valid: \" + value);\n    }\n\n    return null;\n  };\n\n  KeyHashToken.prototype.Encode = function (args) {\n    var val = args.pop();\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      string: val\n    };\n  };\n\n  KeyHashToken.prototype.EncodeObject = function (val) {\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      string: val\n    };\n  };\n\n  KeyHashToken.prototype.ExtractSchema = function () {\n    return KeyHashToken.prim;\n  }; // tslint:disable-next-line: variable-name\n\n\n  KeyHashToken.prototype.ToKey = function (_a) {\n    var string = _a.string,\n        bytes = _a.bytes;\n\n    if (string) {\n      return string;\n    }\n\n    return encodeKeyHash(bytes);\n  };\n\n  KeyHashToken.prototype.ToBigMapKey = function (val) {\n    return {\n      key: {\n        string: val\n      },\n      type: {\n        prim: KeyHashToken.prim\n      }\n    };\n  };\n\n  KeyHashToken.prim = 'key_hash';\n  return KeyHashToken;\n}(ComparableToken);\n\nvar SignatureValidationError =\n/** @class */\nfunction (_super) {\n  __extends(SignatureValidationError, _super);\n\n  function SignatureValidationError(value, token, message) {\n    var _this = _super.call(this, value, token, message) || this;\n\n    _this.value = value;\n    _this.token = token;\n    _this.name = 'SignatureValidationError';\n    return _this;\n  }\n\n  return SignatureValidationError;\n}(TokenValidationError);\n\nvar SignatureToken =\n/** @class */\nfunction (_super) {\n  __extends(SignatureToken, _super);\n\n  function SignatureToken(val, idx, fac) {\n    var _this = _super.call(this, val, idx, fac) || this;\n\n    _this.val = val;\n    _this.idx = idx;\n    _this.fac = fac;\n    return _this;\n  }\n\n  SignatureToken.prototype.Execute = function (val) {\n    return val.string;\n  };\n\n  SignatureToken.prototype.isValid = function (value) {\n    if (validateSignature(value) !== ValidationResult.VALID) {\n      return new SignatureValidationError(value, this, 'Signature is not valid');\n    }\n\n    return null;\n  };\n\n  SignatureToken.prototype.Encode = function (args) {\n    var val = args.pop();\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      string: val\n    };\n  };\n\n  SignatureToken.prototype.EncodeObject = function (val) {\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      string: val\n    };\n  };\n\n  SignatureToken.prototype.ExtractSchema = function () {\n    return SignatureToken.prim;\n  };\n\n  SignatureToken.prim = 'signature';\n  return SignatureToken;\n}(Token);\n\nvar LambdaToken =\n/** @class */\nfunction (_super) {\n  __extends(LambdaToken, _super);\n\n  function LambdaToken(val, idx, fac) {\n    var _this = _super.call(this, val, idx, fac) || this;\n\n    _this.val = val;\n    _this.idx = idx;\n    _this.fac = fac;\n    return _this;\n  }\n\n  LambdaToken.prototype.Execute = function (val) {\n    return val.string;\n  };\n\n  LambdaToken.prototype.Encode = function (args) {\n    var val = args.pop();\n    return val;\n  };\n\n  LambdaToken.prototype.EncodeObject = function (val) {\n    return val;\n  };\n\n  LambdaToken.prototype.ExtractSchema = function () {\n    var _a;\n\n    var leftToken = this.createToken(this.val.args[0], this.idx);\n    var rightToken = this.createToken(this.val.args[1], this.idx + 1);\n    return _a = {}, _a[LambdaToken.prim] = {\n      parameters: leftToken.ExtractSchema(),\n      returns: rightToken.ExtractSchema()\n    }, _a;\n  };\n\n  LambdaToken.prim = 'lambda';\n  return LambdaToken;\n}(Token);\n\nvar OperationToken =\n/** @class */\nfunction (_super) {\n  __extends(OperationToken, _super);\n\n  function OperationToken(val, idx, fac) {\n    var _this = _super.call(this, val, idx, fac) || this;\n\n    _this.val = val;\n    _this.idx = idx;\n    _this.fac = fac;\n    return _this;\n  }\n\n  OperationToken.prototype.Execute = function (val) {\n    return val.string;\n  };\n\n  OperationToken.prototype.Encode = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var val = args.pop();\n    return {\n      string: val\n    };\n  };\n\n  OperationToken.prototype.EncodeObject = function (val) {\n    return {\n      string: val\n    };\n  };\n\n  OperationToken.prototype.ExtractSchema = function () {\n    return OperationToken.prim;\n  };\n\n  OperationToken.prim = 'operation';\n  return OperationToken;\n}(Token);\n\nvar SetValidationError =\n/** @class */\nfunction (_super) {\n  __extends(SetValidationError, _super);\n\n  function SetValidationError(value, token, message) {\n    var _this = _super.call(this, value, token, message) || this;\n\n    _this.value = value;\n    _this.token = token;\n    _this.name = 'SetValidationError';\n    return _this;\n  }\n\n  return SetValidationError;\n}(TokenValidationError);\n\nvar SetToken =\n/** @class */\nfunction (_super) {\n  __extends(SetToken, _super);\n\n  function SetToken(val, idx, fac) {\n    var _this = _super.call(this, val, idx, fac) || this;\n\n    _this.val = val;\n    _this.idx = idx;\n    _this.fac = fac;\n    return _this;\n  }\n\n  Object.defineProperty(SetToken.prototype, \"KeySchema\", {\n    get: function () {\n      return this.createToken(this.val.args[0], 0);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SetToken.prototype.isValid = function (value) {\n    if (Array.isArray(value)) {\n      return null;\n    }\n\n    return new SetValidationError(value, this, 'Value must be an array');\n  };\n\n  SetToken.prototype.Encode = function (args) {\n    var _this = this;\n\n    var val = args.pop();\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return val.sort(this.KeySchema.compare).reduce(function (prev, current) {\n      return __spreadArrays(prev, [_this.KeySchema.EncodeObject(current)]);\n    }, []);\n  };\n\n  SetToken.prototype.Execute = function (val, semantics) {\n    var _this = this;\n\n    return val.reduce(function (prev, current) {\n      return __spreadArrays(prev, [_this.KeySchema.Execute(current, semantics)]);\n    }, []);\n  };\n\n  SetToken.prototype.EncodeObject = function (args) {\n    var _this = this;\n\n    var err = this.isValid(args);\n\n    if (err) {\n      throw err;\n    }\n\n    return args.sort(this.KeySchema.compare).reduce(function (prev, current) {\n      return __spreadArrays(prev, [_this.KeySchema.EncodeObject(current)]);\n    }, []);\n  };\n\n  SetToken.prototype.ExtractSchema = function () {\n    return SetToken.prim;\n  };\n\n  SetToken.prim = 'set';\n  return SetToken;\n}(Token);\n\nvar ChainIDValidationError =\n/** @class */\nfunction (_super) {\n  __extends(ChainIDValidationError, _super);\n\n  function ChainIDValidationError(value, token, message) {\n    var _this = _super.call(this, value, token, message) || this;\n\n    _this.value = value;\n    _this.token = token;\n    _this.name = 'ChainIDValidationError';\n    return _this;\n  }\n\n  return ChainIDValidationError;\n}(TokenValidationError);\n\nvar ChainIDToken =\n/** @class */\nfunction (_super) {\n  __extends(ChainIDToken, _super);\n\n  function ChainIDToken(val, idx, fac) {\n    var _this = _super.call(this, val, idx, fac) || this;\n\n    _this.val = val;\n    _this.idx = idx;\n    _this.fac = fac;\n    return _this;\n  }\n\n  ChainIDToken.prototype.isValid = function (value) {\n    if (validateChain(value) !== ValidationResult.VALID) {\n      return new ChainIDValidationError(value, this, 'ChainID is not valid');\n    }\n\n    return null;\n  };\n\n  ChainIDToken.prototype.Execute = function (val) {\n    return val[Object.keys(val)[0]];\n  };\n\n  ChainIDToken.prototype.ExtractSchema = function () {\n    return ChainIDToken.prim;\n  };\n\n  ChainIDToken.prototype.Encode = function (args) {\n    var val = args.pop();\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      string: val\n    };\n  };\n\n  ChainIDToken.prototype.EncodeObject = function (val) {\n    var err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      string: val\n    };\n  }; // tslint:disable-next-line: variable-name\n\n\n  ChainIDToken.prototype.ToKey = function (_a) {\n    var string = _a.string;\n    return string;\n  };\n\n  ChainIDToken.prototype.ToBigMapKey = function (val) {\n    return {\n      key: {\n        string: val\n      },\n      type: {\n        prim: ChainIDToken.prim\n      }\n    };\n  };\n\n  ChainIDToken.prim = 'chain_id';\n  return ChainIDToken;\n}(ComparableToken);\n\nvar tokens = [PairToken, NatToken, StringToken, BigMapToken, AddressToken, MapToken, BoolToken, OrToken, ContractToken, ListToken, MutezToken, BytesToken, OptionToken, TimestampToken, IntToken, UnitToken, KeyToken, KeyHashToken, SignatureToken, LambdaToken, OperationToken, SetToken, ChainIDToken];\n\nvar InvalidTokenError =\n/** @class */\nfunction () {\n  function InvalidTokenError(message, data) {\n    this.message = message;\n    this.data = data;\n    this.name = 'Invalid token error';\n  }\n\n  return InvalidTokenError;\n}();\n\nfunction createToken(val, idx) {\n  var t = tokens.find(function (x) {\n    return x.prim === val.prim;\n  });\n\n  if (!t) {\n    throw new InvalidTokenError('Malformed data expected a value with a valid prim property', val);\n  }\n\n  return new t(val, idx, createToken);\n}\n/**\r\n * @warn Our current smart contract abstraction feature is currently in preview. It's API is not final, and it may not cover every use case (yet). We will greatly appreciate any feedback on this feature.\r\n */\n\n\nvar Schema =\n/** @class */\nfunction () {\n  function Schema(val) {\n    this.root = createToken(val, 0);\n\n    if (this.root instanceof BigMapToken) {\n      this.bigMap = this.root;\n    } else if (this.isExpressionExtended(val) && val.prim === 'pair') {\n      var exp = val.args[0];\n\n      if (this.isExpressionExtended(exp) && exp.prim === 'big_map') {\n        this.bigMap = new BigMapToken(exp, 0, createToken);\n      }\n    }\n  }\n\n  Schema.fromRPCResponse = function (val) {\n    var storage = val && val.script && Array.isArray(val.script.code) && val.script.code.find(function (x) {\n      return x.prim === 'storage';\n    });\n\n    if (!storage || !Array.isArray(storage.args)) {\n      throw new Error('Invalid rpc response passed as arguments');\n    }\n\n    return new Schema(storage.args[0]);\n  };\n\n  Schema.prototype.isExpressionExtended = function (val) {\n    return 'prim' in val && Array.isArray(val.args);\n  };\n\n  Schema.prototype.removeTopLevelAnnotation = function (obj) {\n    // PairToken and OrToken can have redundant top level annotation in their storage\n    if (this.root instanceof PairToken || this.root instanceof OrToken) {\n      if (this.root.hasAnnotations() && typeof obj === 'object' && Object.keys(obj).length === 1) {\n        return obj[Object.keys(obj)[0]];\n      }\n    }\n\n    return obj;\n  };\n\n  Schema.prototype.Execute = function (val, semantics) {\n    var storage = this.root.Execute(val, semantics);\n    return this.removeTopLevelAnnotation(storage);\n  };\n\n  Schema.prototype.ExecuteOnBigMapDiff = function (diff, semantics) {\n    if (!this.bigMap) {\n      throw new Error('No big map schema');\n    }\n\n    if (!Array.isArray(diff)) {\n      throw new Error('Invalid big map diff. It must be an array');\n    }\n\n    var eltFormat = diff.map(function (_a) {\n      var key = _a.key,\n          value = _a.value;\n      return {\n        args: [key, value]\n      };\n    });\n    return this.bigMap.Execute(eltFormat, semantics);\n  };\n\n  Schema.prototype.ExecuteOnBigMapValue = function (key, semantics) {\n    if (!this.bigMap) {\n      throw new Error('No big map schema');\n    }\n\n    return this.bigMap.ValueSchema.Execute(key, semantics);\n  };\n\n  Schema.prototype.EncodeBigMapKey = function (key) {\n    if (!this.bigMap) {\n      throw new Error('No big map schema');\n    }\n\n    try {\n      return this.bigMap.KeySchema.ToBigMapKey(key);\n    } catch (ex) {\n      throw new Error('Unable to encode big map key: ' + ex);\n    }\n  };\n\n  Schema.prototype.Encode = function (_value) {\n    try {\n      return this.root.EncodeObject(_value);\n    } catch (ex) {\n      if (ex instanceof TokenValidationError) {\n        throw ex;\n      }\n\n      throw new Error(\"Unable to encode storage object. \" + ex);\n    }\n  };\n\n  Schema.prototype.ExtractSchema = function () {\n    return this.removeTopLevelAnnotation(this.root.ExtractSchema());\n  };\n  /**\r\n   * @deprecated\r\n   */\n\n\n  Schema.prototype.ComputeState = function (tx, state) {\n    var _a;\n\n    var _this = this;\n\n    if (!this.bigMap) {\n      throw new Error('No big map schema');\n    }\n\n    var bigMap = tx.reduce(function (prev, current) {\n      return __assign(__assign({}, prev), _this.ExecuteOnBigMapDiff(current.contents[0].metadata.operation_result.big_map_diff));\n    }, {});\n    return __assign(__assign({}, this.Execute(state)), (_a = {}, _a[this.bigMap.annot()] = bigMap, _a));\n  };\n\n  return Schema;\n}();\n/**\r\n * @warn Our current smart contract abstraction feature is currently in preview. It's API is not final, and it may not cover every use case (yet). We will greatly appreciate any feedback on this feature.\r\n */\n\n\nvar ParameterSchema =\n/** @class */\nfunction () {\n  function ParameterSchema(val) {\n    this.root = createToken(val, 0);\n  }\n\n  ParameterSchema.fromRPCResponse = function (val) {\n    var parameter = val && val.script && Array.isArray(val.script.code) && val.script.code.find(function (x) {\n      return x.prim === 'parameter';\n    });\n\n    if (!parameter || !Array.isArray(parameter.args)) {\n      throw new Error('Invalid rpc response passed as arguments');\n    }\n\n    return new ParameterSchema(parameter.args[0]);\n  };\n\n  Object.defineProperty(ParameterSchema.prototype, \"isMultipleEntryPoint\", {\n    get: function () {\n      return this.root instanceof OrToken || this.root instanceof OptionToken && this.root.subToken() instanceof OrToken;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ParameterSchema.prototype, \"hasAnnotation\", {\n    get: function () {\n      if (this.isMultipleEntryPoint) {\n        return Object.keys(this.ExtractSchema())[0] !== '0';\n      } else {\n        return true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ParameterSchema.prototype.Execute = function (val, semantics) {\n    return this.root.Execute(val, semantics);\n  };\n\n  ParameterSchema.prototype.Encode = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    try {\n      return this.root.Encode(args.reverse());\n    } catch (ex) {\n      if (ex instanceof TokenValidationError) {\n        throw ex;\n      }\n\n      throw new Error(\"Unable to encode storage object. \" + ex);\n    }\n  };\n\n  ParameterSchema.prototype.ExtractSchema = function () {\n    return this.root.ExtractSchema();\n  };\n\n  ParameterSchema.prototype.ExtractSignatures = function () {\n    return this.root.ExtractSignature();\n  };\n\n  return ParameterSchema;\n}();\n\nexport { AddressValidationError, BigMapValidationError, BytesValidationError, ChainIDValidationError, ContractValidationError, IntValidationError, KeyHashValidationError, KeyValidationError, ListValidationError, MapValidationError, MutezValidationError, NatValidationError, ParameterSchema, Schema, SetValidationError, SignatureValidationError };","map":{"version":3,"sources":["../src/tokens/token.ts","../src/tokens/bigmap.ts","../src/tokens/or.ts","../src/tokens/pair.ts","../src/tokens/comparable/nat.ts","../src/tokens/comparable/string.ts","../src/tokens/comparable/address.ts","../src/tokens/map.ts","../src/tokens/comparable/bool.ts","../src/tokens/contract.ts","../src/tokens/list.ts","../src/tokens/comparable/mutez.ts","../src/tokens/comparable/bytes.ts","../src/tokens/option.ts","../src/tokens/comparable/timestamp.ts","../src/tokens/comparable/int.ts","../src/tokens/unit.ts","../src/tokens/key.ts","../src/tokens/comparable/key_hash.ts","../src/tokens/signature.ts","../src/tokens/lambda.ts","../src/tokens/operation.ts","../src/tokens/set.ts","../src/tokens/chain-id.ts","../src/tokens/tokens.ts","../src/tokens/createToken.ts","../src/schema/storage.ts","../src/schema/parameter.ts"],"names":[],"mappings":"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","sourcesContent":["import { MichelsonV1Expression } from '@taquito/rpc';\n\nexport abstract class TokenValidationError implements Error {\n  name: string = 'ValidationError';\n  public message: string;\n\n  constructor(public value: any, public token: Token, baseMessage: string) {\n    const annot = this.token.annot();\n    const annotText = annot ? `[${annot}] ` : '';\n    this.message = `${annotText}${baseMessage}`;\n  }\n}\n\nexport type TokenFactory = (val: any, idx: number) => Token;\n\nexport interface Semantic {\n  [key: string]: (value: MichelsonV1Expression, schema: MichelsonV1Expression) => any;\n}\n\nexport abstract class Token {\n  constructor(\n    protected val: { prim: string; args: any[]; annots?: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {}\n\n  annot() {\n    return (Array.isArray(this.val.annots) && this.val.annots.length > 0\n      ? this.val.annots[0]\n      : String(this.idx)\n    ).replace(/(%|\\:)(_Liq_entry_)?/, '');\n  }\n\n  hasAnnotations() {\n    return Array.isArray(this.val.annots) && this.val.annots.length;\n  }\n\n  public createToken = this.fac;\n\n  public abstract ExtractSchema(): any;\n\n  public abstract Execute(val: any, semantics?: Semantic): any;\n\n  public abstract Encode(_args: any[]): any;\n\n  public abstract EncodeObject(args: any): any;\n\n  public ExtractSignature() {\n    return [[this.ExtractSchema()]];\n  }\n}\n\nexport abstract class ComparableToken extends Token {\n  abstract ToBigMapKey(\n    val: string\n  ): {\n    key: { [key: string]: string };\n    type: { prim: string };\n  };\n\n  abstract ToKey(val: string): string;\n\n  compare(o1: string, o2: string) {\n    return o1 < o2 ? -1 : 1;\n  }\n}\n","import { Token, TokenFactory, ComparableToken, Semantic, TokenValidationError } from './token';\n\nexport class BigMapValidationError extends TokenValidationError {\n  name: string = 'BigMapValidationError';\n  constructor(public value: any, public token: BigMapToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class BigMapToken extends Token {\n  static prim = 'big_map';\n  constructor(\n    protected val: { prim: string; args: any[]; annots?: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  get ValueSchema() {\n    return this.createToken(this.val.args[1], 0);\n  }\n\n  get KeySchema(): ComparableToken {\n    return (this.createToken(this.val.args[0], 0) as unknown) as ComparableToken;\n  }\n\n  public ExtractSchema() {\n    return {\n      [this.KeySchema.ExtractSchema()]: this.ValueSchema.ExtractSchema(),\n    };\n  }\n\n  private isValid(value: any): BigMapValidationError | null {\n    if (typeof value === 'object') {\n      return null;\n    }\n\n    return new BigMapValidationError(value, this, 'Value must be an object');\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return Object.keys(val)\n      .sort(this.KeySchema.compare)\n      .map(key => {\n        return {\n          prim: 'Elt',\n          args: [this.KeySchema.Encode([key]), this.ValueSchema.EncodeObject(val[key])],\n        };\n      });\n  }\n\n  public EncodeObject(args: any): any {\n    const val = args;\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return Object.keys(val)\n      .sort(this.KeySchema.compare)\n      .map(key => {\n        return {\n          prim: 'Elt',\n          args: [this.KeySchema.EncodeObject(key), this.ValueSchema.EncodeObject(val[key])],\n        };\n      });\n  }\n\n  public Execute(val: any[] | { int: string }, semantic?: Semantic) {\n    if (semantic && semantic[BigMapToken.prim]) {\n      return semantic[BigMapToken.prim](val as any, this.val);\n    }\n\n    if (Array.isArray(val)) {\n      // Athens is returning an empty array for big map in storage\n      // Internal: In taquito v5 it is still used to decode big map diff (as if they were a regular map)\n      return val.reduce((prev, current) => {\n        return {\n          ...prev,\n          [this.KeySchema.ToKey(current.args[0])]: this.ValueSchema.Execute(current.args[1]),\n        };\n      }, {});\n    } else if ('int' in val) {\n      // Babylon is returning an int with the big map id in contract storage\n      return val.int;\n    } else {\n      // Unknown case\n      throw new Error(\n        `Big map is expecting either an array (Athens) or an object with an int property (Babylon). Got ${JSON.stringify(\n          val\n        )}`\n      );\n    }\n  }\n}\n","import { Token, TokenFactory, Semantic } from './token';\n\nexport class OrToken extends Token {\n  static prim = 'or';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Encode(args: any[]): any {\n    const label = args[args.length - 1];\n\n    const leftToken = this.createToken(this.val.args[0], this.idx);\n    let keyCount = 1;\n    if (leftToken instanceof OrToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n\n    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n\n    if (String(leftToken.annot()) === String(label) && !(leftToken instanceof OrToken)) {\n      args.pop();\n      return { prim: 'Left', args: [leftToken.Encode(args)] };\n    } else if (String(rightToken.annot()) === String(label) && !(rightToken instanceof OrToken)) {\n      args.pop();\n      return { prim: 'Right', args: [rightToken.Encode(args)] };\n    } else {\n      if (leftToken instanceof OrToken) {\n        let val = leftToken.Encode(args);\n        if (val) {\n          return { prim: 'Left', args: [val] };\n        }\n      }\n\n      if (rightToken instanceof OrToken) {\n        let val = rightToken.Encode(args);\n        if (val) {\n          return { prim: 'Right', args: [val] };\n        }\n      }\n      return null;\n    }\n  }\n\n  public ExtractSignature(): any {\n    const leftToken = this.createToken(this.val.args[0], this.idx);\n    let keyCount = 1;\n    if (leftToken instanceof OrToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n\n    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n\n    const newSig = [];\n\n    if (leftToken instanceof OrToken) {\n      newSig.push(...leftToken.ExtractSignature());\n    } else {\n      for (const sig of leftToken.ExtractSignature()) {\n        newSig.push([leftToken.annot(), ...sig]);\n      }\n    }\n\n    if (rightToken instanceof OrToken) {\n      newSig.push(...rightToken.ExtractSignature());\n    } else {\n      for (const sig of rightToken.ExtractSignature()) {\n        newSig.push([rightToken.annot(), ...sig]);\n      }\n    }\n\n    return newSig;\n  }\n\n  public EncodeObject(args: any): any {\n    const label = Object.keys(args)[0];\n\n    const leftToken = this.createToken(this.val.args[0], this.idx);\n    let keyCount = 1;\n    if (leftToken instanceof OrToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n\n    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n\n    if (String(leftToken.annot()) === String(label) && !(leftToken instanceof OrToken)) {\n      return { prim: 'Left', args: [leftToken.EncodeObject(args[label])] };\n    } else if (String(rightToken.annot()) === String(label) && !(rightToken instanceof OrToken)) {\n      return { prim: 'Right', args: [rightToken.EncodeObject(args[label])] };\n    } else {\n      if (leftToken instanceof OrToken) {\n        let val = leftToken.EncodeObject(args);\n        if (val) {\n          return { prim: 'Left', args: [val] };\n        }\n      }\n\n      if (rightToken instanceof OrToken) {\n        let val = rightToken.EncodeObject(args);\n        if (val) {\n          return { prim: 'Right', args: [val] };\n        }\n      }\n      return null;\n    }\n  }\n\n  public Execute(val: any, semantics?: Semantic): any {\n    const leftToken = this.createToken(this.val.args[0], this.idx);\n    let keyCount = 1;\n    if (leftToken instanceof OrToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n\n    if (val.prim === 'Right') {\n      return rightToken.Execute(val.args[0], semantics);\n    } else if (val.prim === 'Left') {\n      return {\n        [leftToken.annot()]: leftToken.Execute(val.args[0], semantics),\n      };\n    } else {\n      throw new Error(`Was expecting Left or Right prim but got: ${val.prim}`);\n    }\n  }\n\n  private traversal(\n    getLeftValue: (token: Token) => any,\n    getRightValue: (token: Token) => any,\n    concat: (left: any, right: any) => any\n  ) {\n    const leftToken = this.createToken(this.val.args[0], this.idx);\n    let keyCount = 1;\n    let leftValue;\n    if (leftToken instanceof OrToken && !leftToken.hasAnnotations()) {\n      leftValue = getLeftValue(leftToken);\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    } else {\n      leftValue = { [leftToken.annot()]: getLeftValue(leftToken) };\n    }\n\n    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n    let rightValue;\n    if (rightToken instanceof OrToken && !rightToken.hasAnnotations()) {\n      rightValue = getRightValue(rightToken);\n    } else {\n      rightValue = { [rightToken.annot()]: getRightValue(rightToken) };\n    }\n\n    const res = concat(leftValue, rightValue);\n\n    return res;\n  }\n  public ExtractSchema(): any {\n    return this.traversal(\n      leftToken => leftToken.ExtractSchema(),\n      rightToken => rightToken.ExtractSchema(),\n      (leftValue, rightValue) => ({\n        ...leftValue,\n        ...rightValue,\n      })\n    );\n  }\n}\n","import { Token, TokenFactory, Semantic } from './token';\nimport { OrToken } from './or';\n\nexport class PairToken extends Token {\n  static prim = 'pair';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Encode(args: any[]): any {\n    const leftToken = this.createToken(this.val.args[0], this.idx);\n    let keyCount = 1;\n    if (leftToken instanceof PairToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n\n    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n\n    return {\n      prim: 'Pair',\n      args: [leftToken.Encode(args), rightToken.Encode(args)],\n    };\n  }\n\n  public ExtractSignature(): any {\n    const leftToken = this.createToken(this.val.args[0], this.idx);\n    let keyCount = 1;\n    if (leftToken instanceof OrToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n\n    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n\n    const newSig = [];\n\n    for (const leftSig of leftToken.ExtractSignature()) {\n      for (const rightSig of rightToken.ExtractSignature()) {\n        newSig.push([...leftSig, ...rightSig]);\n      }\n    }\n\n    return newSig;\n  }\n  public EncodeObject(args: any): any {\n    const leftToken = this.createToken(this.val.args[0], this.idx);\n    let keyCount = 1;\n    if (leftToken instanceof PairToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n\n    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n\n    let leftValue;\n    if (leftToken instanceof PairToken && !leftToken.hasAnnotations()) {\n      leftValue = args;\n    } else {\n      leftValue = args[leftToken.annot()];\n    }\n\n    let rightValue;\n    if (rightToken instanceof PairToken && !rightToken.hasAnnotations()) {\n      rightValue = args;\n    } else {\n      rightValue = args[rightToken.annot()];\n    }\n\n    return {\n      prim: 'Pair',\n      args: [leftToken.EncodeObject(leftValue), rightToken.EncodeObject(rightValue)],\n    };\n  }\n\n  private traversal(getLeftValue: (token: Token) => any, getRightValue: (token: Token) => any) {\n    const leftToken = this.createToken(this.val.args[0], this.idx);\n    let keyCount = 1;\n    let leftValue;\n    if (leftToken instanceof PairToken && !leftToken.hasAnnotations()) {\n      leftValue = getLeftValue(leftToken);\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    } else {\n      leftValue = { [leftToken.annot()]: getLeftValue(leftToken) };\n    }\n\n    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n    let rightValue;\n    if (rightToken instanceof PairToken && !rightToken.hasAnnotations()) {\n      rightValue = getRightValue(rightToken);\n    } else {\n      rightValue = { [rightToken.annot()]: getRightValue(rightToken) };\n    }\n\n    const res = {\n      ...leftValue,\n      ...rightValue,\n    };\n\n    return res;\n  }\n\n  public Execute(val: any, semantics?: Semantic): { [key: string]: any } {\n    return this.traversal(\n      leftToken => leftToken.Execute(val.args[0], semantics),\n      rightToken => rightToken.Execute(val.args[1], semantics)\n    );\n  }\n\n  public ExtractSchema(): any {\n    return this.traversal(\n      leftToken => leftToken.ExtractSchema(),\n      rightToken => rightToken.ExtractSchema()\n    );\n  }\n}\n","import { Token, TokenFactory, ComparableToken, TokenValidationError } from '../token';\nimport BigNumber from 'bignumber.js';\n\nexport class NatValidationError extends TokenValidationError {\n  name: string = 'NatValidationError';\n  constructor(public value: any, public token: NatToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class NatToken extends ComparableToken {\n  static prim = 'nat';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Execute(val: any): { [key: string]: any } {\n    return new BigNumber(val[Object.keys(val)[0]]);\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { int: String(val).toString() };\n  }\n\n  private isValid(val: any): NatValidationError | null {\n    const bigNumber = new BigNumber(val);\n    if (bigNumber.isNaN()) {\n      return new NatValidationError(val, this, `Value is not a number: ${val}`);\n    } else if (bigNumber.isNegative()) {\n      return new NatValidationError(val, this, `Value cannot be negative: ${val}`);\n    } else {\n      return null;\n    }\n  }\n\n  public EncodeObject(val: any): any {\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { int: String(val).toString() };\n  }\n\n  public ExtractSchema() {\n    return NatToken.prim;\n  }\n\n  public ToBigMapKey(val: string) {\n    return {\n      key: { int: val },\n      type: { prim: NatToken.prim },\n    };\n  }\n\n  public ToKey({ int }: any) {\n    return int;\n  }\n}\n","import { Token, TokenFactory, ComparableToken } from '../token';\n\nexport class StringToken extends ComparableToken {\n  static prim = 'string';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Execute(val: any): string {\n    return val[Object.keys(val)[0]];\n  }\n\n  public ExtractSchema() {\n    return StringToken.prim;\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n    return { string: val };\n  }\n\n  public EncodeObject(val: any): any {\n    return { string: val };\n  }\n\n  // tslint:disable-next-line: variable-name\n  public ToKey({ string }: any) {\n    return string;\n  }\n\n  public ToBigMapKey(val: string) {\n    return {\n      key: { string: val },\n      type: { prim: StringToken.prim },\n    };\n  }\n}\n","import { Token, TokenFactory, ComparableToken, TokenValidationError } from '../token';\nimport { b58decode, encodePubKey, validateAddress, ValidationResult } from '@taquito/utils';\n\nexport class AddressValidationError extends TokenValidationError {\n  name: string = 'AddressValidationError';\n  constructor(public value: any, public token: AddressToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class AddressToken extends ComparableToken {\n  static prim = 'address';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public ToBigMapKey(val: any) {\n    const decoded = b58decode(val);\n    return {\n      key: { bytes: decoded },\n      type: { prim: 'bytes' },\n    };\n  }\n\n  private isValid(value: any): AddressValidationError | null {\n    if (validateAddress(value) !== ValidationResult.VALID) {\n      return new AddressValidationError(value, this, `Address is not valid: ${value}`);\n    }\n\n    return null;\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { string: val };\n  }\n\n  public EncodeObject(val: any): any {\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { string: val };\n  }\n\n  // tslint:disable-next-line: variable-name\n  public Execute(val: { bytes: string; string: string }): string {\n    if (val.string) {\n      return val.string;\n    }\n\n    return encodePubKey(val.bytes);\n  }\n\n  public ExtractSchema() {\n    return AddressToken.prim;\n  }\n\n  // tslint:disable-next-line: variable-name\n  public ToKey({ bytes, string }: any) {\n    if (string) {\n      return string;\n    }\n\n    return encodePubKey(bytes);\n  }\n\n  compare(address1: string, address2: string) {\n    const isImplicit = (address: string) => {\n      return address.startsWith('tz');\n    };\n\n    if (isImplicit(address1) && isImplicit(address2)) {\n      return super.compare(address1, address2);\n    } else if (isImplicit(address1)) {\n      return -1;\n    } else if (isImplicit(address2)) {\n      return 1;\n    } else {\n      return super.compare(address1, address2);\n    }\n  }\n}\n","import { Token, TokenFactory, Semantic, TokenValidationError, ComparableToken } from './token';\n\nexport class MapValidationError extends TokenValidationError {\n  name: string = 'MapValidationError';\n  constructor(public value: any, public token: MapToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class MapToken extends Token {\n  static prim = 'map';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  get ValueSchema() {\n    return this.createToken(this.val.args[1], 0);\n  }\n\n  get KeySchema(): ComparableToken {\n    return this.createToken(this.val.args[0], 0) as any;\n  }\n\n  private isValid(value: any): MapValidationError | null {\n    if (typeof value === 'object') {\n      return null;\n    }\n\n    return new MapValidationError(value, this, 'Value must be an object');\n  }\n\n  public Execute(val: any[], semantics?: Semantic): { [key: string]: any } {\n    return val.reduce((prev, current) => {\n      return {\n        ...prev,\n        [this.KeySchema.ToKey(current.args[0])]: this.ValueSchema.Execute(\n          current.args[1],\n          semantics\n        ),\n      };\n    }, {});\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return Object.keys(val)\n      .sort(this.KeySchema.compare)\n      .map(key => {\n        return {\n          prim: 'Elt',\n          args: [this.KeySchema.Encode([key]), this.ValueSchema.EncodeObject(val[key])],\n        };\n      });\n  }\n\n  public EncodeObject(args: any): any {\n    const val = args;\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return Object.keys(val)\n      .sort(this.KeySchema.compare)\n      .map(key => {\n        return {\n          prim: 'Elt',\n          args: [this.KeySchema.EncodeObject(key), this.ValueSchema.EncodeObject(val[key])],\n        };\n      });\n  }\n\n  public ExtractSchema() {\n    return {\n      [this.KeySchema.ExtractSchema()]: this.ValueSchema.ExtractSchema(),\n    };\n  }\n}\n","import { Token, TokenFactory } from '../token';\n\nexport class BoolToken extends Token {\n  static prim = 'bool';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Execute(val: any): boolean {\n    return String(val.prim).toLowerCase() === 'true' ? true : false;\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n    return { prim: val ? 'True' : 'False' };\n  }\n\n  public EncodeObject(val: any) {\n    return { prim: val ? 'True' : 'False' };\n  }\n\n  public ExtractSchema() {\n    return BoolToken.prim;\n  }\n}\n","import { encodePubKey, validateAddress, ValidationResult } from '@taquito/utils';\nimport { Token, TokenFactory, TokenValidationError } from './token';\n\nexport class ContractValidationError extends TokenValidationError {\n  name: string = 'ContractValidationError';\n  constructor(public value: any, public token: ContractToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class ContractToken extends Token {\n  static prim = 'contract';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  private isValid(value: any): ContractValidationError | null {\n    // tz1,tz2 and tz3 seems to be valid contract values (for Unit contract)\n    if (validateAddress(value) !== ValidationResult.VALID) {\n      return new ContractValidationError(value, this, 'Contract address is not valid');\n    }\n\n    return null;\n  }\n\n  public Execute(val: { bytes: string; string: string }) {\n    if (val.string) {\n      return val.string;\n    }\n\n    return encodePubKey(val.bytes);\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n    return { string: val };\n  }\n\n  public EncodeObject(val: any): any {\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n    return { string: val };\n  }\n\n  public ExtractSchema() {\n    return ContractToken.prim;\n  }\n}\n","import { Token, TokenFactory, Semantic, TokenValidationError } from './token';\n\nexport class ListValidationError extends TokenValidationError {\n  name: string = 'ListValidationError';\n  constructor(public value: any, public token: ListToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class ListToken extends Token {\n  static prim = 'list';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  private isValid(value: any): ListValidationError | null {\n    if (Array.isArray(value)) {\n      return null;\n    }\n\n    return new ListValidationError(value, this, 'Value must be an array');\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    const schema = this.createToken(this.val.args[0], 0);\n    return val.reduce((prev: any, current: any) => {\n      return [...prev, schema.EncodeObject(current)];\n    }, []);\n  }\n\n  public Execute(val: any, semantics?: Semantic) {\n    const schema = this.createToken(this.val.args[0], 0);\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return val.reduce((prev: any, current: any) => {\n      return [...prev, schema.Execute(current, semantics)];\n    }, []);\n  }\n\n  public EncodeObject(args: any): any {\n    const schema = this.createToken(this.val.args[0], 0);\n\n    const err = this.isValid(args);\n    if (err) {\n      throw err;\n    }\n\n    return args.reduce((prev: any, current: any) => {\n      return [...prev, schema.EncodeObject(current)];\n    }, []);\n  }\n\n  public ExtractSchema() {\n    return ListToken.prim;\n  }\n}\n","import { Token, TokenFactory, ComparableToken, TokenValidationError } from '../token';\nimport BigNumber from 'bignumber.js';\n\nexport class MutezValidationError extends TokenValidationError {\n  name: string = 'MutezValidationError';\n  constructor(public value: any, public token: MutezToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class MutezToken extends ComparableToken {\n  static prim = 'mutez';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Execute(val: any) {\n    return new BigNumber(val[Object.keys(val)[0]]);\n  }\n\n  public ExtractSchema() {\n    return MutezToken.prim;\n  }\n\n  private isValid(val: any): MutezValidationError | null {\n    const bigNumber = new BigNumber(val);\n    if (bigNumber.isNaN()) {\n      return new MutezValidationError(val, this, `Value is not a number: ${val}`);\n    } else {\n      return null;\n    }\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { int: String(val).toString() };\n  }\n\n  public EncodeObject(val: any): any {\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { int: String(val).toString() };\n  }\n\n  public ToBigMapKey(val: string) {\n    return {\n      key: { int: val },\n      type: { prim: MutezToken.prim },\n    };\n  }\n\n  public ToKey({ int }: any) {\n    return int;\n  }\n}\n","import { Token, TokenFactory, ComparableToken, TokenValidationError } from '../token';\n\nexport class BytesValidationError extends TokenValidationError {\n  name: string = 'BytesValidationError';\n  constructor(public value: any, public token: BytesToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class BytesToken extends ComparableToken {\n  static prim = 'bytes';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public ToBigMapKey(val: string) {\n    return {\n      key: { bytes: val },\n      type: { prim: BytesToken.prim },\n    };\n  }\n\n  private isValid(val: any): BytesValidationError | null {\n    if (typeof val === 'string' && /^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {\n      return null;\n    } else {\n      return new BytesValidationError(val, this, `Invalid bytes: ${val}`);\n    }\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { bytes: String(val).toString() };\n  }\n\n  public EncodeObject(val: any) {\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { bytes: String(val).toString() };\n  }\n\n  public Execute(val: any): string {\n    return val.bytes;\n  }\n\n  public ExtractSchema() {\n    return BytesToken.prim;\n  }\n\n  // tslint:disable-next-line: variable-name\n  public ToKey({ bytes, string }: any) {\n    if (string) {\n      return string;\n    }\n\n    return bytes;\n  }\n}\n","import { Token, TokenFactory, Semantic } from './token';\n\nexport class OptionToken extends Token {\n  static prim = 'option';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public subToken(): Token {\n    return this.createToken(this.val.args[0], this.idx);\n  }\n\n  annot(): string {\n    return Array.isArray(this.val.annots)\n      ? super.annot()\n      : this.createToken(this.val.args[0], this.idx).annot();\n  }\n\n  public Encode(args: any): any {\n    const value = args;\n    if (\n      value === undefined ||\n      value === null ||\n      (Array.isArray(value) && (value[0] === undefined || value[0] === null))\n    ) {\n      return { prim: 'None' };\n    }\n\n    const schema = this.createToken(this.val.args[0], 0);\n    return { prim: 'Some', args: [schema.Encode(args)] };\n  }\n\n  public EncodeObject(args: any): any {\n    const schema = this.createToken(this.val.args[0], 0);\n    const value = args;\n\n    if (value === undefined || value === null) {\n      return { prim: 'None' };\n    }\n\n    return { prim: 'Some', args: [schema.EncodeObject(value)] };\n  }\n\n  public Execute(val: any, semantics?: Semantic) {\n    if (val.prim === 'None') {\n      return null;\n    }\n\n    const schema = this.createToken(this.val.args[0], 0);\n    return schema.Execute(val.args[0], semantics);\n  }\n\n  public ExtractSchema() {\n    const schema = this.createToken(this.val.args[0], 0);\n    return schema.ExtractSchema();\n  }\n\n  public ExtractSignature() {\n    const schema = this.createToken(this.val.args[0], 0);\n    return [...schema.ExtractSignature(), []];\n  }\n}\n","import { Token, TokenFactory, ComparableToken } from '../token';\n\nexport class TimestampToken extends ComparableToken {\n  static prim = 'timestamp';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Execute(val: { string?: string; int?: string }) {\n    if (val.string) {\n      return new Date(val.string).toISOString();\n    } else if (val.int) {\n      return new Date(Number(val.int) * 1000).toISOString();\n    }\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n    return { string: val };\n  }\n\n  public EncodeObject(val: any): any {\n    return { string: val };\n  }\n\n  public ExtractSchema() {\n    return TimestampToken.prim;\n  }\n\n  // tslint:disable-next-line: variable-name\n  public ToKey({ string }: any) {\n    return string;\n  }\n\n  public ToBigMapKey(val: string) {\n    return {\n      key: { string: val },\n      type: { prim: TimestampToken.prim },\n    };\n  }\n}\n","import { Token, TokenFactory, ComparableToken, TokenValidationError } from '../token';\nimport BigNumber from 'bignumber.js';\n\nexport class IntValidationError extends TokenValidationError {\n  name: string = 'IntValidationError';\n  constructor(public value: any, public token: IntToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class IntToken extends ComparableToken {\n  static prim = 'int';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Execute(val: { [key: string]: string }): { [key: string]: any } {\n    return new BigNumber(val[Object.keys(val)[0]]);\n  }\n\n  public ExtractSchema() {\n    return IntToken.prim;\n  }\n\n  private isValid(val: any): IntValidationError | null {\n    const bigNumber = new BigNumber(val);\n    if (bigNumber.isNaN()) {\n      return new IntValidationError(val, this, `Value is not a number: ${val}`);\n    } else {\n      return null;\n    }\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { int: String(val).toString() };\n  }\n\n  public EncodeObject(val: any): any {\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { int: String(val).toString() };\n  }\n\n  public ToBigMapKey(val: string) {\n    return {\n      key: { int: val },\n      type: { prim: IntToken.prim },\n    };\n  }\n\n  public ToKey({ int }: any) {\n    return int;\n  }\n}\n","import { Token, TokenFactory } from './token';\n\nexport class UnitToken extends Token {\n  static prim = 'unit';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Encode(args: any[]): any {\n    args.pop();\n    return { prim: 'Unit' };\n  }\n\n  public EncodeObject(_val: any): any {\n    return { prim: 'Unit' };\n  }\n\n  public Execute(): { [key: string]: any } {\n    return null as any;\n  }\n\n  public ExtractSchema() {\n    return UnitToken.prim;\n  }\n}\n","import { Token, TokenFactory, TokenValidationError } from './token';\nimport { encodeKey, validatePublicKey, ValidationResult } from '@taquito/utils';\n\nexport class KeyValidationError extends TokenValidationError {\n  name: string = 'KeyValidationError';\n  constructor(public value: any, public token: KeyToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class KeyToken extends Token {\n  static prim = 'key';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Execute(val: { bytes: string; string: string }): string {\n    if (val.string) {\n      return val.string;\n    }\n\n    return encodeKey(val.bytes);\n  }\n\n  private isValid(value: any): KeyValidationError | null {\n    if (validatePublicKey(value) !== ValidationResult.VALID) {\n      return new KeyValidationError(value, this, 'Key is not valid');\n    }\n\n    return null;\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { string: val };\n  }\n\n  public EncodeObject(val: any): any {\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { string: val };\n  }\n\n  public ExtractSchema() {\n    return KeyToken.prim;\n  }\n}\n","import { Token, TokenFactory, ComparableToken, TokenValidationError } from '../token';\nimport { encodeKeyHash, validateKeyHash, ValidationResult } from '@taquito/utils';\n\nexport class KeyHashValidationError extends TokenValidationError {\n  name: string = 'KeyHashValidationError';\n  constructor(public value: any, public token: KeyHashToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class KeyHashToken extends ComparableToken {\n  static prim = 'key_hash';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Execute(val: { bytes: string; string: string }): string {\n    if (val.string) {\n      return val.string;\n    }\n\n    return encodeKeyHash(val.bytes);\n  }\n\n  private isValid(value: any): KeyHashValidationError | null {\n    if (validateKeyHash(value) !== ValidationResult.VALID) {\n      return new KeyHashValidationError(value, this, `KeyHash is not valid: ${value}`);\n    }\n\n    return null;\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { string: val };\n  }\n\n  public EncodeObject(val: any): any {\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { string: val };\n  }\n\n  public ExtractSchema() {\n    return KeyHashToken.prim;\n  }\n\n  // tslint:disable-next-line: variable-name\n  public ToKey({ string, bytes }: any) {\n    if (string) {\n      return string;\n    }\n\n    return encodeKeyHash(bytes);\n  }\n\n  public ToBigMapKey(val: string) {\n    return {\n      key: { string: val },\n      type: { prim: KeyHashToken.prim },\n    };\n  }\n}\n","import { Token, TokenFactory, TokenValidationError } from './token';\nimport { validateSignature, ValidationResult } from '@taquito/utils';\n\nexport class SignatureValidationError extends TokenValidationError {\n  name: string = 'SignatureValidationError';\n  constructor(public value: any, public token: SignatureToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class SignatureToken extends Token {\n  static prim = 'signature';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Execute(val: any): { [key: string]: any } {\n    return val.string;\n  }\n\n  private isValid(value: any): SignatureValidationError | null {\n    if (validateSignature(value) !== ValidationResult.VALID) {\n      return new SignatureValidationError(value, this, 'Signature is not valid');\n    }\n\n    return null;\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { string: val };\n  }\n\n  public EncodeObject(val: any): any {\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { string: val };\n  }\n\n  public ExtractSchema() {\n    return SignatureToken.prim;\n  }\n}\n","import { Token, TokenFactory } from './token';\n\nexport class LambdaToken extends Token {\n  static prim = 'lambda';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Execute(val: any): { [key: string]: any } {\n    return val.string;\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n    return val;\n  }\n\n  public EncodeObject(val: any): any {\n    return val;\n  }\n\n  public ExtractSchema() {\n    const leftToken = this.createToken(this.val.args[0], this.idx);\n    const rightToken = this.createToken(this.val.args[1], this.idx + 1);\n    return {\n      [LambdaToken.prim]: {\n        parameters: leftToken.ExtractSchema(),\n        returns: rightToken.ExtractSchema(),\n      },\n    };\n  }\n}\n","import { Token, TokenFactory } from './token';\n\nexport class OperationToken extends Token {\n  static prim = 'operation';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Execute(val: any): { [key: string]: any } {\n    return val.string;\n  }\n\n  public Encode(...args: any[]): any {\n    const val = args.pop();\n    return { string: val };\n  }\n\n  public EncodeObject(val: any): any {\n    return { string: val };\n  }\n\n  public ExtractSchema() {\n    return OperationToken.prim;\n  }\n}\n","import { Token, TokenFactory, Semantic, TokenValidationError, ComparableToken } from './token';\n\nexport class SetValidationError extends TokenValidationError {\n  name: string = 'SetValidationError';\n  constructor(public value: any, public token: SetToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class SetToken extends Token {\n  static prim = 'set';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  get KeySchema(): ComparableToken {\n    return this.createToken(this.val.args[0], 0) as any;\n  }\n\n  private isValid(value: any): SetValidationError | null {\n    if (Array.isArray(value)) {\n      return null;\n    }\n\n    return new SetValidationError(value, this, 'Value must be an array');\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return val.sort(this.KeySchema.compare).reduce((prev: any, current: any) => {\n      return [...prev, this.KeySchema.EncodeObject(current)];\n    }, []);\n  }\n\n  public Execute(val: any, semantics?: Semantic) {\n    return val.reduce((prev: any, current: any) => {\n      return [...prev, this.KeySchema.Execute(current, semantics)];\n    }, []);\n  }\n\n  public EncodeObject(args: any): any {\n    const err = this.isValid(args);\n    if (err) {\n      throw err;\n    }\n\n    return args.sort(this.KeySchema.compare).reduce((prev: any, current: any) => {\n      return [...prev, this.KeySchema.EncodeObject(current)];\n    }, []);\n  }\n\n  public ExtractSchema() {\n    return SetToken.prim;\n  }\n}\n","import { Token, TokenFactory, ComparableToken, TokenValidationError } from './token';\nimport { validateChain, ValidationResult } from '@taquito/utils';\n\nexport class ChainIDValidationError extends TokenValidationError {\n  name: string = 'ChainIDValidationError';\n  constructor(public value: any, public token: ChainIDToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class ChainIDToken extends ComparableToken {\n  static prim = 'chain_id';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  private isValid(value: any): ChainIDValidationError | null {\n    if (validateChain(value) !== ValidationResult.VALID) {\n      return new ChainIDValidationError(value, this, 'ChainID is not valid');\n    }\n\n    return null;\n  }\n\n  public Execute(val: any): string {\n    return val[Object.keys(val)[0]];\n  }\n\n  public ExtractSchema() {\n    return ChainIDToken.prim;\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { string: val };\n  }\n\n  public EncodeObject(val: any): any {\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { string: val };\n  }\n\n  // tslint:disable-next-line: variable-name\n  public ToKey({ string }: any) {\n    return string;\n  }\n\n  public ToBigMapKey(val: string) {\n    return {\n      key: { string: val },\n      type: { prim: ChainIDToken.prim },\n    };\n  }\n}\n","import { PairToken } from './pair';\n\nimport { NatToken } from './comparable/nat';\n\nimport { StringToken } from './comparable/string';\n\nimport { BigMapToken } from './bigmap';\n\nimport { AddressToken } from './comparable/address';\n\nimport { MapToken } from './map';\n\nimport { BoolToken } from './comparable/bool';\n\nimport { OrToken } from './or';\n\nimport { ContractToken } from './contract';\n\nimport { ListToken } from './list';\nimport { MutezToken } from './comparable/mutez';\nimport { BytesToken } from './comparable/bytes';\nimport { OptionToken } from './option';\nimport { TimestampToken } from './comparable/timestamp';\nimport { IntToken } from './comparable/int';\nimport { UnitToken } from './unit';\nimport { KeyToken } from './key';\nimport { KeyHashToken } from './comparable/key_hash';\nimport { SignatureToken } from './signature';\nimport { LambdaToken } from './lambda';\nimport { OperationToken } from './operation';\nimport { SetToken } from './set';\nimport { ChainIDToken } from './chain-id';\n\nexport const tokens = [\n  PairToken,\n  NatToken,\n  StringToken,\n  BigMapToken,\n  AddressToken,\n  MapToken,\n  BoolToken,\n  OrToken,\n  ContractToken,\n  ListToken,\n  MutezToken,\n  BytesToken,\n  OptionToken,\n  TimestampToken,\n  IntToken,\n  UnitToken,\n  KeyToken,\n  KeyHashToken,\n  SignatureToken,\n  LambdaToken,\n  OperationToken,\n  SetToken,\n  ChainIDToken,\n];\n","import { tokens } from './tokens';\nimport { Token } from './token';\n\nexport class InvalidTokenError implements Error {\n  name: string = 'Invalid token error';\n  constructor(public message: string, public data: any) {}\n}\n\nexport function createToken(val: any, idx: number): Token {\n  const t = tokens.find(x => x.prim === val.prim);\n  if (!t) {\n    throw new InvalidTokenError('Malformed data expected a value with a valid prim property', val);\n  }\n  return new t(val, idx, createToken);\n}\n","import { MichelsonV1Expression, MichelsonV1ExpressionExtended, ScriptResponse } from '@taquito/rpc';\nimport { BigMapToken } from '../tokens/bigmap';\nimport { createToken } from '../tokens/createToken';\nimport { OrToken } from '../tokens/or';\nimport { PairToken } from '../tokens/pair';\nimport { Semantic, Token, TokenValidationError } from '../tokens/token';\nimport { RpcTransaction } from './model';\nimport { Falsy } from './types';\n\n/**\n * @warn Our current smart contract abstraction feature is currently in preview. It's API is not final, and it may not cover every use case (yet). We will greatly appreciate any feedback on this feature.\n */\nexport class Schema {\n  private root: Token;\n\n  // TODO: Should we deprecate this?\n  private bigMap?: BigMapToken;\n\n  static fromRPCResponse(val: { script: ScriptResponse }) {\n    const storage: Falsy<MichelsonV1ExpressionExtended> =\n      val &&\n      val.script &&\n      Array.isArray(val.script.code) &&\n      (val.script.code.find((x: any) => x.prim === 'storage') as MichelsonV1ExpressionExtended);\n\n    if (!storage || !Array.isArray(storage.args)) {\n      throw new Error('Invalid rpc response passed as arguments');\n    }\n\n    return new Schema(storage.args[0]);\n  }\n\n  private isExpressionExtended(\n    val: any\n  ): val is Required<Pick<MichelsonV1ExpressionExtended, 'prim' | 'args'>> {\n    return 'prim' in val && Array.isArray(val.args);\n  }\n\n  constructor(val: MichelsonV1Expression) {\n    this.root = createToken(val, 0);\n\n    if (this.root instanceof BigMapToken) {\n      this.bigMap = this.root;\n    } else if (this.isExpressionExtended(val) && val.prim === 'pair') {\n      const exp = val.args[0];\n      if (this.isExpressionExtended(exp) && exp.prim === 'big_map') {\n        this.bigMap = new BigMapToken(exp, 0, createToken);\n      }\n    }\n  }\n\n  private removeTopLevelAnnotation(obj: any) {\n    // PairToken and OrToken can have redundant top level annotation in their storage\n    if (this.root instanceof PairToken || this.root instanceof OrToken) {\n      if (this.root.hasAnnotations() && typeof obj === 'object' && Object.keys(obj).length === 1) {\n        return obj[Object.keys(obj)[0]];\n      }\n    }\n\n    return obj;\n  }\n\n  Execute(val: any, semantics?: Semantic) {\n    const storage = this.root.Execute(val, semantics);\n\n    return this.removeTopLevelAnnotation(storage);\n  }\n\n  ExecuteOnBigMapDiff(diff: any[], semantics?: Semantic) {\n    if (!this.bigMap) {\n      throw new Error('No big map schema');\n    }\n\n    if (!Array.isArray(diff)) {\n      throw new Error('Invalid big map diff. It must be an array');\n    }\n\n    const eltFormat = diff.map(({ key, value }) => ({ args: [key, value] }));\n\n    return this.bigMap.Execute(eltFormat, semantics);\n  }\n\n  ExecuteOnBigMapValue(key: any, semantics?: Semantic) {\n    if (!this.bigMap) {\n      throw new Error('No big map schema');\n    }\n\n    return this.bigMap.ValueSchema.Execute(key, semantics);\n  }\n\n  EncodeBigMapKey(key: string) {\n    if (!this.bigMap) {\n      throw new Error('No big map schema');\n    }\n\n    try {\n      return this.bigMap.KeySchema.ToBigMapKey(key);\n    } catch (ex) {\n      throw new Error('Unable to encode big map key: ' + ex);\n    }\n  }\n\n  Encode(_value?: any) {\n    try {\n      return this.root.EncodeObject(_value);\n    } catch (ex) {\n      if (ex instanceof TokenValidationError) {\n        throw ex;\n      }\n\n      throw new Error(`Unable to encode storage object. ${ex}`);\n    }\n  }\n\n  ExtractSchema() {\n    return this.removeTopLevelAnnotation(this.root.ExtractSchema());\n  }\n\n  /**\n   * @deprecated\n   */\n  ComputeState(tx: RpcTransaction[], state: any) {\n    if (!this.bigMap) {\n      throw new Error('No big map schema');\n    }\n\n    const bigMap = tx.reduce((prev, current) => {\n      return {\n        ...prev,\n        ...this.ExecuteOnBigMapDiff(current.contents[0].metadata.operation_result.big_map_diff),\n      };\n    }, {});\n\n    return {\n      ...this.Execute(state),\n      [this.bigMap.annot()]: bigMap,\n    };\n  }\n}\n","import { createToken } from '../tokens/createToken';\nimport { Token, Semantic, TokenValidationError } from '../tokens/token';\nimport { OrToken } from '../tokens/or';\nimport { OptionToken } from '../tokens/option';\nimport { ScriptResponse, MichelsonV1ExpressionExtended, MichelsonV1Expression } from '@taquito/rpc';\nimport { Falsy } from './types';\n\n/**\n * @warn Our current smart contract abstraction feature is currently in preview. It's API is not final, and it may not cover every use case (yet). We will greatly appreciate any feedback on this feature.\n */\nexport class ParameterSchema {\n  private root: Token;\n\n  static fromRPCResponse(val: { script: ScriptResponse }) {\n    const parameter: Falsy<MichelsonV1ExpressionExtended> =\n      val &&\n      val.script &&\n      Array.isArray(val.script.code) &&\n      (val.script.code.find((x: any) => x.prim === 'parameter') as MichelsonV1ExpressionExtended);\n    if (!parameter || !Array.isArray(parameter.args)) {\n      throw new Error('Invalid rpc response passed as arguments');\n    }\n\n    return new ParameterSchema(parameter.args[0]);\n  }\n\n  get isMultipleEntryPoint() {\n    return (\n      this.root instanceof OrToken ||\n      (this.root instanceof OptionToken && this.root.subToken() instanceof OrToken)\n    );\n  }\n\n  get hasAnnotation() {\n    if (this.isMultipleEntryPoint) {\n      return Object.keys(this.ExtractSchema())[0] !== '0';\n    } else {\n      return true;\n    }\n  }\n\n  constructor(val: MichelsonV1Expression) {\n    this.root = createToken(val, 0);\n  }\n\n  Execute(val: any, semantics?: Semantic) {\n    return this.root.Execute(val, semantics);\n  }\n\n  Encode(...args: any[]) {\n    try {\n      return this.root.Encode(args.reverse());\n    } catch (ex) {\n      if (ex instanceof TokenValidationError) {\n        throw ex;\n      }\n\n      throw new Error(`Unable to encode storage object. ${ex}`);\n    }\n  }\n\n  ExtractSchema() {\n    return this.root.ExtractSchema();\n  }\n\n  ExtractSignatures() {\n    return this.root.ExtractSignature();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}